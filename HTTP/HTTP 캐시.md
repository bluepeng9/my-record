- 작성일: 2023-05-04
- 태그: 
- 분류
    - [HTTP 메시지](HTTP%20메시지.md)
- 관련 노트
---

# INDEX

- [HTTP Proxy 캐시](HTTP%20Proxy%20캐시.md)
- [HTTP 캐시 무효화](HTTP%20캐시%20무효화.md)

---

```
+-----------------+       +-----------------+       +-----------------+
|                 |       |                 |       |                 |
|    Server       |       |     Cache       |       |     Client      |
|                 |       |                 |       |                 |
+-----------------+       +-----------------+       +-----------------+
      ^                            ^                      ^   ^
      |                            |                      |   |
      |                            +----------------------+   |
      |                                                       |
      +-------------------------------------------------------+
```

HTTP 캐시 헤더에 대해 알아보겠습니다.

---

# 캐시 제어 헤더

`Cache-Control`헤더에 대해 알아보겠습니다.

- `Cache-Control: max-age`
    - 캐시 유효 시간, 초 단위
- `Cache-Control: no-cache`
    - 데이터는 캐시해도 되지만, 항상 origin 서버에 검증한 이후 사용해야 합니다.
- `Cache-Control: no-store`
    - 데이터에 민감한 정보가 있으므로 저장하면 안 됩니다.
        - 메모리에서 사용하고 최대한 빨리 삭제합니다.

이외에도 `Pragma`, `Expires가` 있지만 `Cache-Control`을 주로 사용합니다.

----

# 동작 원리

기본적인 캐시의 동작 원리는 다음과 같습니다.

1. 클라이언트가 서버에 `GET` 요청을 보냅니다.
2. 서버는 `cache-control` 헤더에 유효시간을 설정해 응답합니다.
3. 유효시간동안 클라이언트는 캐시의 데이터를 사용합니다.
4. 유효시간이 지나면 서버에 데이터를 다시 요청 합니다.

## Last-modified, if-modifed-since

캐시 유효시간이 초과되면 서버를 통해 데이터를 다시 조회하고 다운로드 받아야 합니다. 따라서 네트워크 비용이 증가하는 문제가 있습니다. 이를 해결하기 위해 검증 헤더를 추가합니다.

1. 클라이언트가 서버에 `GET` 요청을 보냅니다.
2. 서버는 `cache-control` 헤더에 유효시간과 `Last-modifed` 헤더에 최종 수정일을 설정해 응답합니다.
3. 유효시간동안 클라이언트는 캐시의 데이터를 사용합니다.
4. 유효시간이 지나면 서버에 데이터를 다시 요청 합니다.
    1. 이 때 캐시에 저장해 두었던 `Last-modifed` 값을 `if-modified-since` 헤더에 붙여 보냅니다.
5. 이후로 데이터가 수정 되지 않았다면, 서버는 304 상태코드와 함께 body가 없는 메시지를 클라이언트에게 전달합니다.
6. 클라이언트는 `cache-control`과 같은 헤더를 갱신하고 재사용합니다.


`Last-modified` , `if-modified-since`를 사용하면 다음과 같은 한계가 있습니다.

- 1초 미만 단위로 캐시 조정이 불가능
- 날짜 기반의 로직 사용합니다.
- 서버에서 별도의 캐시 로직을 사용할 수 없습니다.
    - e.g. 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

## Etag, If-None-Match

다음과 같은 특징이 있습니다.

- 캐시용 데이터에 임의의 고유한 버전 이름을 달아줍니다.
    - e.g.
        - `ETag: "v1.0"`
- 데이터가 변경되면 이 이름을 바꾸어 변경합니다.(Hash를 다시 생성)
- e.g.
    - `ETag: "aaaaa"` -> `ETag: "bbbbb"`
- 단순하게 `ETag`만 보내서 같으면 데이터를 유지하고, 다르면 다시 받습니다.

다음과 같이 동작합니다.

1. 클라이언트가 서버에 `GET` 요청을 보냅니다.
2. 서버는 `cache-control`, `Etag`와 함께 응답을 보냅니다.
3. 유효시간 초과 시 클라이언트는 `If-None-Match` 헤더에 `Etag`값을 붙여 서버에 `get` 요청을 보냅니다.
4. `Etag`가 같다면 서버는 304 응답을 보냅니다.
5. 클라이언트는 캐시를 갱신하고 재사용합니다.

다음과 같은 장점이 있습니다.

- `Etag`만 비교하므로 단순합니다.
- 캐시 제어로직을 서버에서 관리할 수 있습니다.

# 정리

캐시를 사용하지 않는다면 다음과 같은 단점이 있습니다.

- 데이터가 변경되지 않아도 계속 비싼 네트워크를 통해서 데이터를 다운로드 받아야 합니다.
- 브라우저 로딩 속도가 느려집니다.

캐시를 적용함으로써 다음과 같은 장점을 얻을 수 있습니다.

- 캐시 가능 시간동안 네트워크를 사용하지 않아도 됩니다.
- 브라우저 로딩 속도가 빨라집니다

정리하면 다음과 같습니다.

- 캐시 유효 시간이 초과되어도 서버의 데이터가 갱신되지 않았다면 304 + 헤더 메타 정보만 응답합니다.
- 결과적으로는 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 할 수 있습니다.


---

# Reference

- [모든 개발자를 위한 HTTP 웹 기본 지식 - 인프런 | 강의 (inflearn.com)](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)